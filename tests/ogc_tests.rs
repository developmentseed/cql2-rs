use assert_json_diff::assert_json_eq;
use cql2::parse;
use rstest::rstest;
use serde_json::json;
use std::fs;
use std::path::PathBuf;

pub fn validate_str(cql2: &str) {
    println!("CQL2: {}", cql2);
    let expr: cql2::Expr = parse(cql2);
    let outcql2: String = expr.as_cql2_text();
    println!("Out CQL2: {}", outcql2);
    println!("Expr:  {}", expr.as_json());
    let valid = expr.validate();
    assert!(valid);
    // make sure that the cql2 text generated by as_cql2 is valid as well

    let expr2: cql2::Expr = parse(&outcql2);
    let js = expr2.as_json();
    println!("Expr2: {}", js);
    let valid2 = expr2.validate();
    assert!(valid2);

    // make sure that when reparsing the output that the json is the same
    let expr3 = parse(&js);
    println!("Expr3: {}", expr3.as_json());
    assert_json_eq!(json!(js), json!(expr3.as_json()));
}

pub fn validate_file(f: &str) {
    println!("File Path: {:#?}", f);
    let cql2 = fs::read_to_string(f).unwrap();
    validate_str(&cql2);
}

#[rstest]
fn for_each_text_file(#[files("tests/fixtures/text/*.txt")] path: PathBuf) {
    validate_file(path.to_str().expect("reason"));
}

#[rstest]
fn for_each_json_file(#[files("tests/fixtures/json/*.json")] path: PathBuf) {
    validate_file(path.to_str().expect("reason"));
}

#[rstest]
fn between_tests() {
    validate_str("true and a between 1 and 2 and false")
}
